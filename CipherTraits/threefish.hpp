#pragma once
#include "../Config.hpp"
#include "../Array.hpp"
#include "../Block.hpp"
#include "../Intrinsic.hpp"
#include "Internal/threefish_constant.hpp"

namespace accel::CipherTraits {

    template<size_t __KeyBits>
    class THREEFISH_ALG : public Internal::THREEFISH_CONSTANT<__KeyBits> {
        static_assert(__KeyBits == 256 || __KeyBits == 512 || __KeyBits == 1024,
                      "THREEFISH_ALG failure! Unsupported __KeyBits.");
    public:
        static constexpr size_t BlockSizeValue = __KeyBits / 8;
        static constexpr size_t KeySizeValue = __KeyBits / 8;
    private:

        static constexpr size_t _Nw = BlockSizeValue / sizeof(uint64_t);
        static constexpr size_t _Nr = __KeyBits > 512 ? 80 : 72;

        using BlockType = Block<uint64_t, _Nw, 16>;
        static_assert(sizeof(BlockType) == BlockSizeValue);

        ACCEL_FORCEINLINE
        static void _MIXFunction(uint64_t& x0, uint64_t& x1, unsigned d, unsigned j) ACCEL_NOEXCEPT {
            x0 += x1;
            x1 = RotateShiftLeft(x1, Internal::THREEFISH_CONSTANT<__KeyBits>::RotationConstant[d % 8][j]) ^ x0;
        }

        ACCEL_FORCEINLINE
        static void _InverseMIXFunction(uint64_t& x0, uint64_t& x1, unsigned d, unsigned j) ACCEL_NOEXCEPT {
            x1 = RotateShiftRight(x1 ^ x0, Internal::THREEFISH_CONSTANT<__KeyBits>::RotationConstant[d % 8][j]);
            x0 -= x1;
        }

        ACCEL_FORCEINLINE
        void _KeySchedule(const uint64_t* p8bUserKey, uint64_t t0, uint64_t t1) ACCEL_NOEXCEPT {
            Array<uint64_t, _Nw + 1> k;
            Array<uint64_t, 3> t;

            k[_Nw] = 0x1BD11BDAA9FC1A22u;
            for (size_t i = 0; i < _Nw; ++i) {
                if constexpr (accel::NativeEndianness == Endianness::LittleEndian) {
                    k[i] = MemoryReadAs<uint64_t>(&p8bUserKey[i]);
                } else {
                    k[i] = ByteSwap<uint64_t>(MemoryReadAs<uint64_t>(&p8bUserKey[i]));
                }
                k[_Nw] ^= k[i];
            }

            t[0] = t0;
            t[1] = t1;
            t[2] = t0 ^ t1;

            for (size_t s = 0; s <= _Nr / 4; ++s) {
                for (size_t i = 0; i <= _Nw - 4; ++i) {
                    _Key[s][i] = k[(s + i) % (_Nw + 1)];
                }
                _Key[s][_Nw - 3] = k[(s + _Nw - 3) % (_Nw + 1)] + t[s % 3];
                _Key[s][_Nw - 2] = k[(s + _Nw - 2) % (_Nw + 1)] + t[(s + 1) % 3];
                _Key[s][_Nw - 1] = k[(s + _Nw - 1) % (_Nw + 1)] + static_cast<uint64_t>(s);
            }

            k.SecureZero();
            t.SecureZero();
        }

        ACCEL_FORCEINLINE
        void _EncryptProcess(BlockType& RefBlock) const ACCEL_NOEXCEPT {
            for (unsigned d = 0; d < _Nr; ++d) {
                if (d % 4 == 0) {
                    for (size_t i = 0; i < _Nw; ++i)
                        RefBlock[i] += _Key[d / 4][i];
                }

                for (unsigned j = 0; j < _Nw / 2; ++j) {
                    _MIXFunction(RefBlock[2 * j], RefBlock[2 * j + 1], d, j);
                }

                /* the code that performs Pi-shuffle is generated by the following python3.7 script

#!/usr/bin/env python3
from collections import OrderedDict

def GenerateCppCodeShuffle(TabWidth, ElementTypeName, ArrayName, From, To):
    transf = { f : t for f, t in zip(From, To) if f != t }

    chain_list = []
    while len(transf):
        chain = OrderedDict()
        cur_key = list(transf.keys())[0]
        while True:
            try:
                cur_val = transf.pop(cur_key)
                chain.update({ cur_key : cur_val })
                cur_key = cur_val
            except KeyError:
                break
        chain_list.append(chain)

    print(' ' * TabWidth + f'{ElementTypeName} temp;')
    print()
    for chain in chain_list:
        first_key = list(chain.keys())[0]
        last_key = list(chain.keys())[-1]

        print(' ' * TabWidth + f'temp = {ArrayName}[{first_key}];')
        for k, v in chain.items():
            if k != last_key:
                print(' ' * TabWidth + f'{ArrayName}[{k}] = {ArrayName}[{v}];')
            else:
                print(' ' * TabWidth + f'{ArrayName}[{k}] = temp;')
        print()

print('if constexpr (__KeyBits == 256) {')
GenerateCppCodeShuffle(4, 'uint64_t', '_Key', [0, 1, 2, 3], [0, 3, 2, 1])
print('}')

print('if constexpr (__KeyBits == 512) {')
GenerateCppCodeShuffle(4, 'uint64_t', '_Key', [0, 1, 2, 3, 4, 5, 6, 7], [2, 1, 4, 7, 6, 5, 0, 3])
print('}')

print('if constexpr (__KeyBits == 1024) {')
GenerateCppCodeShuffle(4, 'uint64_t', '_Key', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1])
print('}')

                */
                if constexpr (__KeyBits == 256) {
                    uint64_t temp;

                    temp = RefBlock[1];
                    RefBlock[1] = RefBlock[3];
                    RefBlock[3] = temp;
                }

                if constexpr (__KeyBits == 512) {
                    uint64_t temp;

                    temp = RefBlock[0];
                    RefBlock[0] = RefBlock[2];
                    RefBlock[2] = RefBlock[4];
                    RefBlock[4] = RefBlock[6];
                    RefBlock[6] = temp;

                    temp = RefBlock[3];
                    RefBlock[3] = RefBlock[7];
                    RefBlock[7] = temp;
                }

                if constexpr (__KeyBits == 1024) {
                    uint64_t temp;

                    temp = RefBlock[1];
                    RefBlock[1] = RefBlock[9];
                    RefBlock[9] = RefBlock[7];
                    RefBlock[7] = RefBlock[15];
                    RefBlock[15] = temp;

                    temp = RefBlock[3];
                    RefBlock[3] = RefBlock[13];
                    RefBlock[13] = RefBlock[5];
                    RefBlock[5] = RefBlock[11];
                    RefBlock[11] = temp;

                    temp = RefBlock[4];
                    RefBlock[4] = RefBlock[6];
                    RefBlock[6] = temp;

                    temp = RefBlock[8];
                    RefBlock[8] = RefBlock[10];
                    RefBlock[10] = RefBlock[12];
                    RefBlock[12] = RefBlock[14];
                    RefBlock[14] = temp;
                }
            }

            for (size_t i = 0; i < _Nw; ++i) 
                RefBlock[i] += _Key[_Nr / 4][i];
        }

        ACCEL_FORCEINLINE
        void _DecryptProcess(BlockType& RefBlock) const ACCEL_NOEXCEPT {
            for (size_t i = 0; i < _Nw; ++i)
                RefBlock[i] -= _Key[_Nr / 4][i];

            for (unsigned d = _Nr - 1; d != static_cast<unsigned>(-1); --d) {
                /* the code that performs inverse Pi-shuffle is generated by the following python3.7 script

#!/usr/bin/env python3
from collections import OrderedDict

def GenerateCppCodeShuffle(TabWidth, ElementTypeName, ArrayName, From, To):
    transf = { f : t for f, t in zip(From, To) if f != t }

    chain_list = []
    while len(transf):
        chain = OrderedDict()
        cur_key = list(transf.keys())[0]
        while True:
            try:
                cur_val = transf.pop(cur_key)
                chain.update({ cur_key : cur_val })
                cur_key = cur_val
            except KeyError:
                break
        chain_list.append(chain)

    print(' ' * TabWidth + f'{ElementTypeName} temp;')
    print()
    for chain in chain_list:
        first_key = list(chain.keys())[0]
        last_key = list(chain.keys())[-1]

        print(' ' * TabWidth + f'temp = {ArrayName}[{first_key}];')
        for k, v in chain.items():
            if k != last_key:
                print(' ' * TabWidth + f'{ArrayName}[{k}] = {ArrayName}[{v}];')
            else:
                print(' ' * TabWidth + f'{ArrayName}[{k}] = temp;')
        print()

print('if constexpr (__KeyBits == 256) {')
GenerateCppCodeShuffle(4, 'uint64_t', 'RefBlock', [0, 3, 2, 1], [0, 1, 2, 3])
print('}')

print('if constexpr (__KeyBits == 512) {')
GenerateCppCodeShuffle(4, 'uint64_t', 'RefBlock', [2, 1, 4, 7, 6, 5, 0, 3], [0, 1, 2, 3, 4, 5, 6, 7])
print('}')

print('if constexpr (__KeyBits == 1024) {')
GenerateCppCodeShuffle(4, 'uint64_t', 'RefBlock', [0, 9, 2, 13, 6, 11, 4, 15, 10, 7, 12, 3, 14, 5, 8, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
print('}')

                */
                if constexpr (__KeyBits == 256) {
                    uint64_t temp;

                    temp = RefBlock[3];
                    RefBlock[3] = RefBlock[1];
                    RefBlock[1] = temp;
                }

                if constexpr (__KeyBits == 512) {
                    uint64_t temp;

                    temp = RefBlock[2];
                    RefBlock[2] = RefBlock[0];
                    RefBlock[0] = RefBlock[6];
                    RefBlock[6] = RefBlock[4];
                    RefBlock[4] = temp;

                    temp = RefBlock[7];
                    RefBlock[7] = RefBlock[3];
                    RefBlock[3] = temp;
                }

                if constexpr (__KeyBits == 1024) {
                    uint64_t temp;

                    temp = RefBlock[9];
                    RefBlock[9] = RefBlock[1];
                    RefBlock[1] = RefBlock[15];
                    RefBlock[15] = RefBlock[7];
                    RefBlock[7] = temp;

                    temp = RefBlock[13];
                    RefBlock[13] = RefBlock[3];
                    RefBlock[3] = RefBlock[11];
                    RefBlock[11] = RefBlock[5];
                    RefBlock[5] = temp;

                    temp = RefBlock[6];
                    RefBlock[6] = RefBlock[4];
                    RefBlock[4] = temp;

                    temp = RefBlock[10];
                    RefBlock[10] = RefBlock[8];
                    RefBlock[8] = RefBlock[14];
                    RefBlock[14] = RefBlock[12];
                    RefBlock[12] = temp;
                }

                for (unsigned j = 0; j < _Nw / 2; ++j) {
                    _InverseMIXFunction(RefBlock[2 * j], RefBlock[2 * j + 1], d, j);
                }

                if (d % 4 == 0) {
                    for (size_t i = 0; i < _Nw; ++i)
                        RefBlock[i] -= _Key[d / 4][i];
                }
            }
        }

        Array<uint64_t, _Nr / 4 + 1, _Nw> _Key;

    public:

        constexpr size_t BlockSize() const ACCEL_NOEXCEPT {
            return BlockSizeValue;
        }

        constexpr size_t KeySize() const ACCEL_NOEXCEPT {
            return KeySizeValue;
        }

        ACCEL_NODISCARD
        bool SetKey(const void* pbUserKey, size_t cbUserKey, uint64_t Tweak1, uint64_t Tweak2) ACCEL_NOEXCEPT {
            if (cbUserKey != KeySizeValue) {
                return false;
            } else {
                _KeySchedule(reinterpret_cast<const uint64_t*>(pbUserKey), Tweak1, Tweak2);
                return true;
            }
        }

        size_t EncryptBlock(void* pbPlaintext) const ACCEL_NOEXCEPT {
            BlockType Text;

            Text.template LoadFrom<Endianness::LittleEndian>(pbPlaintext);
            _EncryptProcess(Text);
            Text.template StoreTo<Endianness::LittleEndian>(pbPlaintext);

            return BlockSizeValue;
        }

        size_t DecryptBlock(void* pbCiphertext) const ACCEL_NOEXCEPT {
            BlockType Text;

            Text.template LoadFrom<Endianness::LittleEndian>(pbCiphertext);
            _DecryptProcess(Text);
            Text.template StoreTo<Endianness::LittleEndian>(pbCiphertext);

            return BlockSizeValue;
        }

        void ClearKey() ACCEL_NOEXCEPT {
            _Key.SecureZero();
        }

        ~THREEFISH_ALG() ACCEL_NOEXCEPT {
            _Key.SecureZero();
        }
    };

}

